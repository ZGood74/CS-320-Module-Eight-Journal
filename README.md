# CS-320-Module-Eight-Journal

Overview

This repository contains key artifacts from my CS 320 course, showcasing my work in software testing, automation, and quality assurance. Included are the contact service files from Project One and a summary and reflections report from Project Two. These documents highlight my ability to create unit tests, analyze different testing approaches, and apply effective testing strategies to ensure high-quality software.

Reflection

How can I ensure that my code, program, or software is functional and secure?

Ensuring that code is functional and secure requires a combination of rigorous testing, careful coding practices, and constant vigilance. I achieved this by writing comprehensive JUnit tests for each component of the contact service, task service, and appointment service in Project One. These tests were designed to cover all functional requirements, ensuring that the code behaves as expected under various conditions. Additionally, I implemented validation checks within the classes to prevent invalid data from being processed, thereby increasing the overall security of the application.

How do I interpret user needs and incorporate them into a program?

Interpreting user needs starts with a thorough understanding of the project requirements. For both projects, I carefully analyzed the provided requirements to ensure that each service met the specified criteria. I translated these requirements into specific functionalities within the code, such as enforcing character limits and ensuring that IDs are unique and immutable. This approach ensures that the final product aligns with the userâ€™s expectations and functional needs.

How do I approach designing software?

My approach to designing software is methodical and user-centered. I begin by thoroughly understanding the user requirements and then mapping these needs to specific features in the software. In Project One, I followed a structured approach where I first created the service classes to handle the core functionalities, then developed unit tests to validate these functionalities. In Project Two, I reflected on the testing strategies used, ensuring that they were both effective and aligned with the project requirements. Moving forward, I plan to continue using a test-driven development approach, where writing tests guides the design and implementation of the code, ensuring both functionality and quality.
